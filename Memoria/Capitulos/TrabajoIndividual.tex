\chapter{Trabajo individual}
\label{cap:trabajoIndiv}

En este capítulo se detalla el trabajo realizado por cada integrante del grupo de trabajo de este proyecto. En la Sección \ref{sec:trabajoBelen} se expone el trabajo realizado por Belén Serrano Antón, mientras que la Sección \ref{sec:trabajoClara} expone el de Clara de Suso Seijas.

\section{Belén}
\label{sec:trabajoBelen}

Antes de decidir el tema sobre el que iba a realizar mi Trabajo de Fin de grado, abordé con Raquel Hervás diferentes posibilidades a finales del curso anterior. Todas ellas tenían un punto en común: la mejora del día a día del usuario final. El resultado de esas investigaciones previas acabaron derivando en el proyecto expuesto a lo largo de este documento, que tiene como finalidad la adaptación del interior de un edificio a personas con discapacidad visual. Ya en septiembre de este curso el equipo de trabajo se cerró con la llegada de Clara.

Ambas comenzamos a estudiar distintos trabajos que se habían hecho en el área de la navegación por interiores y que conforma el Capítulo \ref{cap:estadoDeLaCuestion}. Nos repartimos el trabajo entre las dos, mientras que yo me encargué de la investigación de las aplicaciones \textit{Google Maps} y \textit{BlindSquare}, Clara ultimó el resto. Además, tuvimos la oportunidad de entrevistarnos en el Centro de Tiflotecnología e Innovación de la ONCE gracias a la profesora María Guijarro. Entre Clara y yo recogimos las notas que, posteriormente, darían lugar al Capítulo \ref{cap:once}.

Una vez se habían sentado las bases del trabajo y establecido que la tecnología utilizada iban a ser las balizas Bluetooth, me encargué de salvar la primera barrera tecnológica: poner en funcionamiento los \textit{beacons}. Para ello fue necesaria la revisión de la SDK de \textit{Kontakt}, así como la realización de diversos tutoriales a partir de los cuales ganar soltura con el nuevo entorno de desarrollo, Android Studio. El tiempo invertido en ello me permitió implementar dos aplicaciones sencillas pero funcionales, \textit{miniapp} y \textit{cuadrantes\_v1} (ver Sección \ref{sec:estudioPrecisionBeacons}). Más tarde implementaría \textit{pruebaSonido}, que recoge la lógica necesaria para detectar el \textit{beacon} más cercano. Gracias a ellas se pudo comenzar el estudio de la precisión y el comportamiento de las balizas. Las mediciones expuestas en el Capítulo \ref{cap:descripcionTrabajo} (ver Sección \ref{sub:pruebasCuadrantesv1}) y en el Anexo \ref{Appendix:ResMediciones}, son el resultado de varios días de trabajo en los que se trataron distintas ubicaciones de los \textit{beacons} y se tomaron decisiones sobre la posición en la que se colocarían. Algunas de esas jornadas Clara y yo trabajamos de manera conjunta en la Facultad de Informática de la UCM y, en otras ocasiones, hice yo mediciones en solitario, cuyos resultados compartiría con Clara para su posterior discusión. Tras el estudio de los datos obtenidos se elaboraron de manera conjunta gráficas que permitieran observar el comportamiento de los \textit{beacons} de manera simplificada.

\subsection{Servidor}

Antes de comenzar con el mapeo de la Facultad ambas revisamos el trabajo de \cite{TFGguia}, con la intención de encontrar un modelo de mapeo en el que sustentar el nuestro. Además, revisamos el código del servidor de este mismo trabajo, a partir del cual me encargué de la total adaptación del mismo a nuestro proyecto\footnote{A excepción de los archivos de lectura de XML, que serían modificados por ambas a partir de la nueva información añadida.}. Para ello, en primer lugar tuve que implementar una clase Cliente en Java a través de la cual mandar mensajes al servidor para observar el funcionamiento del código. El resultado de este estudio fue la rápida sustitución del algoritmo que generaba los cuadrantes de la ruta por el algoritmo de \textit{Dijkstra}, debido a que la otra versión no generaba una lista ordenada de cuadrantes, que era lo que se buscaba. Tras ese cambio fueron diversas las pruebas que realicé utilizando los archivos XML de \cite{TFGguia}. Una vez comprobado que el código del servidor funcionaba (al menos técnicamente), Clara se encargó de realizar el mapeo de la Facultad. Mientras tanto, seguí haciendo modificaciones sobre el código del servidor. Entre ellas, numerosos cambios en la función \textit{generar}. Esta función se adaptó a lo que nosotras buscábamos: instrucciones en cada cuadrante, indicación sobre la posición final del destino, adición de información adicional sobre la ruta, etc (ver Sección \ref{sub:genInstruc}). De estos cambios destaca el hecho de que el código encargado de señalizar los giros (ver Sección \ref{sub:instr_giro}) quedó simplificado en gran medida y de que de la función \textit{generar} se eliminaron todas las dependencias del edificio\footnote{Cabe destacar que este proceso fue iterativo y fueron muchas las pruebas realizadas durante el mismo a fin de obtener un código libre de errores (o lo más libre posible).}. Esto último implicó fijar el orden en el que los archivos XML son leídos. Puesto que el código debe ser independiente del número de plantas del edificio, se presupone que el argumento de \textit{Z} (ver Sección \ref{sub:mapeo_xml}) en el XML, que corresponde con el número de planta, es la posición del array en el que se guardan los cuadrantes que pertenecen a una planta. De esta manera, los cuadrantes con $Z = 0$ se guardan en la posición $0$, los de $Z = 1$ en la posición $1$ y así sucesivamente. Esto no ocurría en la primera versión, puesto que comenzamos a mapear la Facultad por la primera planta. Tras darme cuenta de este problema, decidí renombrar todos los cuadrantes mapeados, tanto en los XML como en las referencias de la memoria, comenzando por la planta baja\footnote{Hay que tener en cuenta que el cuadrante \textit{i-ésimo} del array de cuadrantes debe corresponder con el cuadrante con identificador $i$.}, permitiendo así el mapeo de cuantas plantas se quieran. Otra consecuencia de la generalidad de la función \textit{generar} fue la adición de información a los archivos XML. Concretamente añadí los pesos de la matriz de adyacencia, que hasta entonces se modificaban desde el código, y la posición del punto de interés de un cuadrante, que anteriormente se asumía dependiendo del número de este. 


Otro de los grandes cambios del servidor que realicé fue la sustitución de la conexión cliente-servidor, cambiando los \textit{sockets} por \textit{webSockets}. Lo que se buscaba con ello es que el código del servidor pudiera quedar en un servidor externo, de manera que conociendo su \textit{uri}, se pudiera acceder desde cualquier red. Esto suponía un punto fundamental, pues sin ello no se podía probar la aplicación desde la Facultad\footnote{Hasta entonces las pruebas las había realizado sobre la red interna de mi casa.}. Raquel y Gonzalo gestionaron el acceso a un repositorio \textit{Holstein}, desde el cual traté, en numerosas ocasiones, instalar Tomcat y poner en funcionamiento una conexión mediante \textit{webSockets}. Finalmente, tras varias semanas sin encontrar el error y debido a la imposibilidad de acudir a la Facultad\footnote{Debido a la crisis sanitaria por la COVID-19.} por si fuera necesario un reinicio del servidor por la modificación de alguno de sus parámetros de configuración, Gonzalo nos dio acceso a una máquina virtual de la Universidad. Esta vez la instalación de Tomcat\footnote{Los \textit{webSockets} están disponibles a partir de la versión $9$ de Tomcat.} y el posterior despliegue del código del servidor sí tuvo éxito. Una vez se resolvió la parte técnica de esta conexión implementé un nuevo Main para el servidor, el cual recibía la información del cliente por medio de un \textit{webSocket}. A fin de poder realizar pruebas en el servidor sin tener que utilizar mi dispositivo móvil ni los \textit{beacons}, elaboré un archivo \textit{WebSocketClient.html} muy sencillo a través del cual poder mandar mensajes al servidor y leer su respuesta. Esto fue de gran ayuda pues me permitió probar numerosas rutas sin necesidad de simularlas mediante \textit{beacons}. De esta manera cuando realizaba pruebas desde la aplicación sabía de antemano que el código del servidor funcionaba, ayudándome a descartar posibles fallos de este. 


En cuanto a la memoria, me encargué de la redacción de la Sección \ref{sec:servidor}.

\subsection{Cliente}

Respecto al cliente, mi trabajo comenzó con los primeros bocetos de la interfaz, que fueron discutidos y modificados entre Clara y yo, y, posteriormente, con los directores. Yo me encargué de la implementación de la pantalla principal y de una versión anterior de la pantalla destinos, en la cual los botones destino no eran dinámicos, incluyendo la funcionalidad de la barra de búsqueda y el micrófono. Así mismo, el código que permite la conexión con el servidor fue implementado por mí y posteriormente modificado, tras el cambio de \textit{sockets} a \textit{webSockets}. Buena parte del código de la pantalla de ruta está reciclado del código de \textit{cuadrantes\_v1} y \textit{pruebaSonido}, pues estas ya se encargaban del escaneo de \textit{beacons} y, la última, tenía la lógica que permitía reconocer el \textit{beacon} más cercano. Sin embargo, sobre ella tuvo que implementarse la lógica correspondiente a la guía, que fue realizado entre Clara y yo (concretamente, realicé la funcionalidad del botón \textit{Instrucciones detalldas} y parte de la lógica correspondiente al seguimiento de la ruta). Esto constituyó la primera versión de la aplicación, sobre la cual realicé diversas pruebas, tanto del código de la propia aplicación como de la correcta conexión con el servidor. Gracias a que Raquel y Gonzalo me prestaron algunos \textit{beacons} antes del confinamiento, tuve la oportunidad de recrear algunos espacios de la facultad con ellos y así poder \textit{debuggear} nuestro código. Más tarde modifiqué el código del seguimiento de la ruta, haciendo que este solo llamara una vez al servidor por cada ruta solicitada\footnote{Antes se llamaba al servidor cada vez que se quería dar una nueva instrucción.}. Este cambio implicó también la manera en la que el servidor generaba el mensaje, pues, tras el cambio, debía contener toda la información relativa a la ruta en él. También añadí vibraciones distintas para el giro a la derecha y a la izquierda, haciendo que el servidor enviara información que indicara la dirección del giro y no un simple \textit{booleano} que indicaba si había que girar o no. Mi colaboración en la pantalla de ruta finaliza con la implementación de la funcionalidad el modo silencio o \textit{mute}, correspondiente al botón del altavoz en la parte superior, que también se encuentra en la pantalla de instrucciones (ver Figura \ref{fig:interfaz}). La última parte del código que se implementó fue la correspondiente a las pantallas de modo de uso, para las cuales codifiqué la lógica necesaria para la pantalla de instrucciones, que permite reutilizar la misma pantalla y navegar por la guía de uso con los botones \textit{siguiente} y \textit{anterior}. Por último, Clara implementó los botones de la pantalla de destinos de manera dinámica, para lo cual simplemente aporté la lógica necesaria para que los botones se mostraran en el mismo orden en el que habían sido introducidos en el XML\footnote{Esto fue necesario puesto que el nombre de los destinos se almacena en una tabla hash, la cual no respeta el orden.} mediante la utilización de una lista.

Una vez se terminó con la codificación y prueba de las distintas funcionalidades de la aplicación, diseñé el logotipo de Blind Bit, cuyo color y aspecto fue modificado en colaboración con Clara. Esto me dio paso a dotar de un aspecto más corporativo a la aplicación, incluyendo los colores establecidos (morado y lila) en la interfaz. Tras algunas reuniones se decidieron los colores finales y la disposición de los mismos en los botones (de manera salteada).

En cuanto a la memoria, me encargué de la redacción de las Secciones \ref{sub:func_cliente}. La Sección \ref{sec:adaptacion} fue redactada de manera conjunta.

\subsection{Evaluación}

Debido a la situación de confinamiento que vivimos a partir del mes de marzo, nuestros planes de realizar una evaluación con usuarios y poder probar nuestra aplicación en la Facultad se vieron truncados. A pesar de ello, alumnas y directores comentamos posibles soluciones. Al final decidimos que realizar la evaluación de la aplicación era un punto importante del trabajo, para lo cual me ofrecí a desempeñarla en mi propia casa. Clara se encargó del mapeo de la vivienda, sobre los planos que proporcioné, mientras que yo me centré en el diseño y ejecución de las pruebas. Estas pruebas debían ser suficientes para demostrar tanto los puntos fuertes como las carencias de la aplicación. La ejecución de las mismas se adaptó tanto a los medios de los que disponía (solo contaba con $10$ \textit{beacons}, por lo que fue necesaria la redistribución de los mismos para diferentes pruebas) como al espacio (hubo que lidiar con la distribución de mi casa, incluyendo la parte estructural del edificio así como el mobiliario).

Durante la evaluación fueron algunos aspectos de implementación los que necesitaron algún ajuste o corrección pero todos ellos fueron solventados. Por último, redacté y detallé los resultados de la evaluación en la memoria (ver Capítulo \ref{cap:evaluacion}).

\section{Clara}
\label{sec:trabajoClara}